//Link: https://goo.gl/oBfoLX

//Vertex:

precision highp float;
attribute vec3 position;
attribute vec3 normal;
uniform mat3 normalMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
varying vec3 fNormal;
varying vec3 fPosition;
varying vec3 vColor;
uniform float time;
varying vec3 localPos;
const float Pi = 3.1415926;
void main()
{
  fNormal = normalize(normalMatrix * normal);
  vec4 pos = modelViewMatrix * vec4(position, 1.0);
  fPosition = pos.xyz;
  float r=0.2;
  float g=0.2;
  float b=0.2;
  
  vColor = vec3(r,g,b);
  localPos = position;
  gl_Position = projectionMatrix * pos;
}

//Fragment:

precision highp float;
varying vec3 fNormal;
varying vec3 fPosition;
varying vec3 vColor;
uniform float time;
const float Pi = 3.1415926;
const float ambient_coeff   = 0.5;
const float specular_coeff  = 2.0;
const float specular_exp    = 32.0;
varying vec3 localPos;
const vec3  light_color     = vec3(1.0,1.0,1.0);

void main()
{
  float angle = mod(time * 20.0 , 2.0*Pi);
  vec3 dir = vec3(cos(angle),0,sin(angle));
  vec3 color = vColor;
  vec3 l = normalize(dir);
  vec3 n = normalize(fNormal);
  vec3 e = normalize(-fPosition);
  vec3 h = normalize (e+l);
  vec3 dir2 = vec3(0.0,1.0,0.0);
  vec3 l2 = normalize(dir2);
  vec3 h2 = normalize(e+l2);


  color.r = smoothstep(0.0, 0.4, mod(sqrt(pow(localPos.x,2.0)+pow(localPos.y,2.0)),0.4))+0.5;
  if(color.r>1.0){
    color.r = 2.0 - color.r;
  }
  color.r=pow(color.r,3.0);
  color.g = smoothstep(0.0, 0.4, mod(sqrt(pow(localPos.x,2.0)+pow(localPos.z,2.0)),0.4))+0.5;
  if(color.g>1.0){
    color.g = 2.0 - color.g;
  }
  color.g=pow(color.g,3.0);
  color.b = smoothstep(0.0, 0.4, mod(sqrt(pow(localPos.z,2.0)+pow(localPos.y,2.0)),0.4))+0.5;
  if(color.b>1.0){
    color.b = 2.0 - color.b;
  }
  color.b=pow(color.b,3.0);
  
  
  
  float r=0.0;
  float g=0.0;
  float b=0.0;
  float arctan;
  if(localPos.x>0.0){
    arctan=atan(localPos.y/localPos.x)+0.5*Pi;
  }
  else{
    arctan=atan(localPos.y/localPos.x)+3.0/2.0*Pi;
  }
  if((arctan-angle<2.0/3.0*Pi) && (arctan-angle>0.0)){
    r = smoothstep(0.0, Pi*2.0/3.0, arctan-angle);
  }
  else if(arctan-angle+2.0*Pi<2.0/3.0*Pi && arctan-angle<0.0){
    r = smoothstep(0.0, Pi*2.0/3.0, arctan-angle+2.0*Pi);  
  }
  if((arctan-angle<4.0/3.0*Pi) && (arctan-angle>2.0/3.0*Pi)){
    g = smoothstep(0.0, Pi*2.0/3.0, arctan-angle-2.0/3.0*Pi);
  }
  else if(arctan-angle+2.0*Pi<4.0/3.0*Pi && arctan-angle+2.0*Pi>2.0/3.0*Pi){
    g = smoothstep(0.0, Pi*2.0/3.0, arctan-angle+2.0*Pi-2.0/3.0*Pi);  
  }
  if((arctan-angle<2.0*Pi) && (arctan-angle>4.0/3.0*Pi)){
    b = smoothstep(0.0, Pi*2.0/3.0, arctan-angle-4.0/3.0*Pi);
  }
  else if(arctan-angle+2.0*Pi<2.0*Pi && arctan-angle+2.0*Pi>4.0/3.0*Pi){
    b = smoothstep(0.0, Pi*2.0/3.0, arctan-angle+2.0*Pi-4.0/3.0*Pi);
  }
  vec3 vColor2=vec3(vColor.r+r+0.1,vColor.g+g+0.1,vColor.b+b+0.1);
  
  
  
  float diffuse = 0.5 + dot(fNormal,dir);
  float diffuse2 = 0.5 + dot(fNormal,dir2);
  vec3 ambient_color  = ambient_coeff  * color;
  vec3 specular_color = specular_coeff * pow(max(0.0,dot(n,h)),specular_exp) * light_color;
  vec3 specular2 = specular_coeff * pow(max(0.0,dot(n,h2)),specular_exp) * light_color;

  gl_FragColor = vec4(ambient_color+specular_color*diffuse+diffuse2*specular2+vColor2*0.15,1.0);
}